use ipv8::networking::serialization::Packet;
use ipv8::networking::payloads::binmemberauthenticationpayload::BinMemberAuthenticationPayload;
use ipv8::networking::serialization::varlen::VarLen16;
use ipv8::networking::payloads::timedistributionpayload::TimeDistributionPayload;
use ipv8::networking::payloads::puncturepayload::PuncturePayload;
use ipv8::networking::address::Address;
use std::net::Ipv4Addr;
use ipv8::networking::payloads::introductionrequestpayload::IntroductionRequestPayload;
use ipv8::networking::payloads::connectiontype::ConnectionType;
use ipv8::networking::serialization::rawend::RawEnd;
use ipv8::networking::serialization::header::DefaultHeader;

#[test]
fn test_pyipv8_packet_1(){
  let data = Packet(vec![0x00, 0x02, 0xba, 0xf3, 0x0e, 0xd9, 0x19, 0x2b, 0xa3, 0x54, 0xcd, 0xd7, 0xb1, 0x73, 0xe0, 0xef, 0x2c, 0x32, 0x80, 0x27, 0xf1, 0xd3, 0xf5, 0x00, 0x4a, 0x4c, 0x69, 0x62, 0x4e, 0x61, 0x43, 0x4c, 0x50, 0x4b, 0x3a, 0x51, 0xe7, 0x12, 0xc4, 0xeb, 0x8a, 0xc2, 0x5a, 0xe3, 0xa5, 0x68, 0x24, 0x08, 0xb2, 0xad, 0xbd, 0x6b, 0x78, 0xa4, 0x25, 0x54, 0x7f, 0x26, 0x85, 0xcf, 0xdf, 0x1e, 0xe9, 0x27, 0x0c, 0xbe, 0x7e, 0xc3, 0x36, 0xc4, 0x16, 0x0f, 0xf5, 0x72, 0x05, 0x4c, 0x87, 0x78, 0x42, 0xbe, 0x37, 0x73, 0x50, 0x45, 0xa9, 0x3b, 0xc4, 0xe2, 0x04, 0x15, 0x31, 0x6f, 0xdb, 0x14, 0x71, 0x61, 0xa2, 0xd7, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x51, 0xab, 0x1b, 0xc2, 0x2b, 0x67, 0xc0, 0xa8, 0x01, 0x4b, 0x1f, 0x9a, 0xc0, 0xa8, 0x01, 0x4b, 0x1f, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x0e, 0x00, 0x00, 0x00, 0x00, 0xce, 0xe9, 0x32, 0x6b, 0x9d, 0xd4, 0xbb, 0x8a, 0xaf, 0x8d, 0xc0, 0x39, 0x28, 0x8e, 0xbf, 0xc2, 0x4a, 0x10, 0xad, 0xc3, 0x7a, 0xf1, 0xd9, 0xc8, 0x04, 0x17, 0x72, 0x5d, 0x2d, 0x3e, 0x5e, 0x07, 0x52, 0x4d, 0xab, 0x6e, 0xa7, 0x1b, 0x17, 0x5a, 0x77, 0x5d, 0xb5, 0xd8, 0x91, 0x0c, 0x2b, 0x4b, 0xc8, 0xbb, 0x03, 0xd3, 0x55, 0xed, 0x10, 0x26, 0xdd, 0xbb, 0xd8, 0xb2, 0x3b, 0xfd, 0xfc, 0x01, ]);
  let mut deserializer = data.start_deserialize();

  let header: DefaultHeader = deserializer.get_header().unwrap();
  assert_eq!(header,DefaultHeader{
    version: 2,
    mid_hash: [186, 243, 14, 217, 25, 43, 163, 84, 205, 215, 177, 115, 224, 239, 44, 50, 128, 39, 241, 211],
    message_type: 245,
  });


  assert!(deserializer.verify());
}

#[test]
fn test_packet_2() {
  let data = Packet(vec![0x00, 0x02, 0x7e, 0x31, 0x36, 0x85, 0xc1, 0x91, 0x2a, 0x14, 0x12, 0x79, 0xf8, 0x24, 0x8f, 0xc8, 0xdb, 0x58, 0x99, 0xc5, 0xdf, 0x5a, 0xf6, 0x00, 0x80, 0x30, 0x7e, 0x30, 0x10, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x24, 0x03, 0x6a, 0x00, 0x04, 0x00, 0x07, 0xb6, 0x1a, 0xa9, 0x73, 0x6a, 0xe6, 0x6d, 0x38, 0x21, 0x0c, 0x44, 0x7b, 0x76, 0x14, 0x22, 0x9c, 0x8c, 0xe6, 0x6d, 0x93, 0x31, 0xcb, 0x30, 0x84, 0x1d, 0x4d, 0xfc, 0xef, 0x9e, 0xf4, 0x3b, 0xd0, 0xdc, 0xc8, 0x3b, 0xc5, 0x97, 0x17, 0x3f, 0x8d, 0xff, 0x89, 0x0d, 0x8e, 0xb8, 0xb6, 0xc1, 0x0e, 0x34, 0x4e, 0x00, 0x39, 0x92, 0x6f, 0xed, 0x72, 0xb5, 0x86, 0x19, 0x0a, 0x4d, 0x12, 0xd8, 0x20, 0x02, 0xe9, 0x3f, 0x76, 0x64, 0x8d, 0xfb, 0xf1, 0x61, 0x22, 0xd5, 0x21, 0x06, 0x90, 0x50, 0x77, 0x9a, 0xbb, 0x3d, 0xfd, 0x99, 0xd0, 0xf6, 0x7c, 0x19, 0x9b, 0x1f, 0xe8, 0x86, 0x99, 0xaa, 0x06, 0xa1, 0x78, 0x29, 0xbb, 0x2e, 0xb2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x83, 0xb4, 0x1b, 0x9c, 0x19, 0x18, 0xc0, 0xa8, 0x01, 0x4b, 0x1f, 0x9a, 0xc0, 0xa8, 0x01, 0x4b, 0x1f, 0x9a, 0x01, 0x00, 0x21, 0x00, 0x6b, 0x07, 0xdd, 0x2a, 0x8d, 0x0e, 0x53, 0x75, 0xd6, 0x7d, 0x53, 0x78, 0xa1, 0x03, 0x71, 0xba, 0xb6, 0x71, 0x48, 0x9a, 0x8a, 0x5f, 0xb2, 0xec, 0x82, 0x70, 0x12, 0x33, 0x0c, 0xf9, 0x78, 0x4c, 0x64, 0x4d, 0x90, 0x0f, 0x03, 0xb8, 0x03, 0x1e, 0x9e, 0x34, 0xf3, 0xb2, 0xc9, 0x70, 0x82, 0xa9, 0x10, 0x19, 0x8a, 0x00, 0x5e, 0xab, 0x24, 0xd9, 0x9d, 0x53, 0xc3, 0x76, 0x72, 0xc6, 0x72, 0xc6, 0x4d, 0xa5, 0xd3, 0xe9, 0x3c, 0xea, 0x4d, 0x9d, 0x38, 0x18, 0x22, 0x44, 0xc1, 0x5f, 0x06, 0x2a, 0x22, 0xe7, 0xf6, 0xf3, 0x17, 0x27, 0x88, 0xcd, 0xca, 0x1b, 0x62, 0xeb, 0x0d, 0xe2, 0x68, 0x18, 0xaf, 0xa8, 0xa0, 0xef, 0x4e, 0x63, 0x56,]);
  let mut deserializer = data.start_deserialize();
  let header: DefaultHeader = deserializer.get_header().unwrap();

  assert!(deserializer.verify());
}

//// NOTE: headers are not yet supported so are excluded from all of the testcases below. Headers should be (hex) 00 02 + a hash of 20 bytes
//
//#[test]
//fn test_pyipv8_packet_noheader_notrailer_1() {
//  // this is slightly sanitized but REAL data from py-ipv8.
//  // the sanitation process was removing the headers and converting to hexadecimal.
//  // some more even more realistic tests will be coming.
//
//  let data = Packet(vec![0x00, 0x4a, 0x4c, 0x69, 0x62, 0x4e, 0x61, 0x43, 0x4c, 0x50, 0x4b, 0x3a, 0x51, 0xe7, 0x12, 0xc4, 0xeb, 0x8a, 0xc2, 0x5a, 0xe3, 0xa5, 0x68, 0x24, 0x08, 0xb2, 0xad, 0xbd, 0x6b, 0x78, 0xa4, 0x25, 0x54, 0x7f, 0x26, 0x85, 0xcf, 0xdf, 0x1e, 0xe9, 0x27, 0x0c, 0xbe, 0x7e, 0xc3, 0x36, 0xc4, 0x16, 0x0f, 0xf5, 0x72, 0x05, 0x4c, 0x87, 0x78, 0x42, 0xbe, 0x37, 0x73, 0x50, 0x45, 0xa9, 0x3b, 0xc4, 0xe2, 0x04, 0x15, 0x31, 0x6f, 0xdb, 0x14, 0x71, 0x61, 0xa2, 0xd7, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0xa8, 0x01, 0x4b, 0x1f, 0x9a, 0x49, 0x91, 0x8a, 0xe9, 0x1e, 0x4f, 0xff, 0xa6, 0x68, ]);
//  let mut iter = data.deserialize_multiple();
//
//  assert_eq!(
//    BinMemberAuthenticationPayload {
//      public_key_bin: VarLen16(
//        vec![76, 105, 98, 78, 97, 67, 76, 80, 75, 58, 81, 231, 18, 196, 235, 138, 194, 90, 227, 165, 104, 36, 8, 178, 173, 189, 107, 120, 164, 37, 84, 127, 38, 133, 207, 223, 30, 233, 39, 12, 190, 126, 195, 54, 196, 22, 15, 245, 114, 5, 76, 135, 120, 66, 190, 55, 115, 80, 69, 169, 59, 196, 226, 4, 21, 49, 111, 219, 20, 113, 97, 162, 215, 70]
//      )
//    },
//    iter.next().unwrap()
//  );
//
//  assert_eq!(
//    TimeDistributionPayload{
//      global_time:15,
//    },
//    iter.next().unwrap()
//  );
//
//  assert_eq!(
//    PuncturePayload {
//      lan_walker_address: Address {
//        address: Ipv4Addr::new(192, 168, 1, 75),
//        port: 8090
//      },
//      wan_walker_address: Address {
//        address: Ipv4Addr::new(73,145,138,233),
//        port: 7759
//      },
//      identifier: 65446
//    },
//    iter.next().unwrap()
//  )
//}
//
//#[test]
//fn test_pyipv8_packet_noheader_notrailer_2() {
//  // this is slightly sanitized but REAL data from py-ipv8.
//  // the sanitation process was removing the headers and converting to hexadecimal.
//  // some more even more realistic tests will be coming.
//
//  let data = Packet(vec![0x00, 0x4a, 0x4c, 0x69, 0x62, 0x4e, 0x61, 0x43, 0x4c, 0x50, 0x4b, 0x3a, 0x51, 0xe7, 0x12, 0xc4, 0xeb, 0x8a, 0xc2, 0x5a, 0xe3, 0xa5, 0x68, 0x24, 0x08, 0xb2, 0xad, 0xbd, 0x6b, 0x78, 0xa4, 0x25, 0x54, 0x7f, 0x26, 0x85, 0xcf, 0xdf, 0x1e, 0xe9, 0x27, 0x0c, 0xbe, 0x7e, 0xc3, 0x36, 0xc4, 0x16, 0x0f, 0xf5, 0x72, 0x05, 0x4c, 0x87, 0x78, 0x42, 0xbe, 0x37, 0x73, 0x50, 0x45, 0xa9, 0x3b, 0xc4, 0xe2, 0x04, 0x15, 0x31, 0x6f, 0xdb, 0x14, 0x71, 0x61, 0xa2, 0xd7, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xaf, 0xc0, 0xa8, 0x01, 0x4c, 0x1f, 0x9a, 0x51, 0xab, 0x1b, 0xc2, 0x3d, 0xf7, 0x79, 0x93]);
//  let mut iter = data.deserialize_multiple();
//
//  assert_eq!(
//    BinMemberAuthenticationPayload {
//      public_key_bin: VarLen16(
//        vec![76, 105, 98, 78, 97, 67, 76, 80, 75, 58, 81, 231, 18, 196, 235, 138, 194, 90, 227, 165, 104, 36, 8, 178, 173, 189, 107, 120, 164, 37, 84, 127, 38, 133, 207, 223, 30, 233, 39, 12, 190, 126, 195, 54, 196, 22, 15, 245, 114, 5, 76, 135, 120, 66, 190, 55, 115, 80, 69, 169, 59, 196, 226, 4, 21, 49, 111, 219, 20, 113, 97, 162, 215, 70]
//      )
//    },
//    iter.next().unwrap()
//  );
//
//  assert_eq!(
//    TimeDistributionPayload{
//      global_time: 431,
//    },
//    iter.next().unwrap()
//  );
//
//  assert_eq!(
//    PuncturePayload {
//      lan_walker_address: Address {
//        address: Ipv4Addr::new(192, 168, 1, 76),
//        port: 8090
//      },
//      wan_walker_address: Address {
//        address: Ipv4Addr::new(81,171,27,194),
//        port: 15863
//      },
//      identifier: 31123
//    },
//    iter.next().unwrap()
//  )
//}
//
//#[test]
//fn test_pyipv8_packet_noheader_notrailer_3() {
//  // this is slightly sanitized but REAL data from py-ipv8.
//  // the sanitation process was removing the headers and converting to hexadecimal.
//  // some more even more realistic tests will be coming.
//
//  let data = Packet(vec![0x00, 0x4a, 0x4c, 0x69, 0x62, 0x4e, 0x61, 0x43, 0x4c, 0x50, 0x4b, 0x3a, 0x51, 0xe7, 0x12, 0xc4, 0xeb, 0x8a, 0xc2, 0x5a, 0xe3, 0xa5, 0x68, 0x24, 0x08, 0xb2, 0xad, 0xbd, 0x6b, 0x78, 0xa4, 0x25, 0x54, 0x7f, 0x26, 0x85, 0xcf, 0xdf, 0x1e, 0xe9, 0x27, 0x0c, 0xbe, 0x7e, 0xc3, 0x36, 0xc4, 0x16, 0x0f, 0xf5, 0x72, 0x05, 0x4c, 0x87, 0x78, 0x42, 0xbe, 0x37, 0x73, 0x50, 0x45, 0xa9, 0x3b, 0xc4, 0xe2, 0x04, 0x15, 0x31, 0x6f, 0xdb, 0x14, 0x71, 0x61, 0xa2, 0xd7, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x51, 0xab, 0x1b, 0xc2, 0x2b, 0x67, 0xc0, 0xa8, 0x01, 0x4b, 0x1f, 0x9a, 0xc0, 0xa8, 0x01, 0x4b, 0x1f, 0x9a, 0x01, 0x00, 0x97, 0x00, 0x00, 0x00, 0x00, 0x03, 0xa5, 0xdb, 0xf5, 0xcc, 0x02, 0x1a, 0x21, 0xe9, 0x70, 0x2d, 0x8a, 0xf2, 0x91, 0xb4, 0x62, 0x49, 0x91, 0xb2, 0x41, 0x08, 0x89, 0xe3, 0x45, 0xa1, 0x9c, 0x2f, 0xf9, 0x0b, 0x60, 0x26, 0xc9, 0x70, 0x68, 0x2a, 0xbc, 0xd1, 0x03, 0x47, 0x2d, 0xfd, 0xee, 0x19, 0xd8, 0xf9, 0x48, 0x6e, 0xbf, 0x2b, 0xfd, 0xe7, 0x0c, 0x86, 0xd7, 0xbc, 0x00, 0xa6, 0x21, 0xfe, 0x26, 0x22, 0x89, 0xda, 0x0b, ]);
//  let mut iter = data.deserialize_multiple();
//
//  assert_eq!(
//    BinMemberAuthenticationPayload {
//      public_key_bin: VarLen16(
//        vec![76, 105, 98, 78, 97, 67, 76, 80, 75, 58, 81, 231, 18, 196, 235, 138, 194, 90, 227, 165, 104, 36, 8, 178, 173, 189, 107, 120, 164, 37, 84, 127, 38, 133, 207, 223, 30, 233, 39, 12, 190, 126, 195, 54, 196, 22, 15, 245, 114, 5, 76, 135, 120, 66, 190, 55, 115, 80, 69, 169, 59, 196, 226, 4, 21, 49, 111, 219, 20, 113, 97, 162, 215, 70]
//      )
//    },
//    iter.next().unwrap()
//  );
//
//  assert_eq!(
//    TimeDistributionPayload{
//      global_time: 151,
//    },
//    iter.next().unwrap()
//  );
//
//  // tmp to verify the introduction request payload. Maybe useful for verifying the todos below.
//  // let p: IntroductionRequestPayload = iter.next().unwrap();
//  // println!("{:?}",p);
//
//  assert_eq!(
//    IntroductionRequestPayload {
//
//      destination_address: Address {
//        address: Ipv4Addr::new(81, 171, 27, 194),
//        port: 11111
//      },
//      source_lan_address: Address {
//        address: Ipv4Addr::new(192,168,1,75),
//        port: 8090
//      },
//      source_wan_address: Address {
//        address: Ipv4Addr::new(192,168,1,75),
//        port: 8090
//      },
//      // TODO i am not entirely sure of the extraction of bits is 100% right. though public does seem plausible.
//      advice: false,
//      connection_type: ConnectionType::PUBLIC,
//      identifier:151,
//      // TODO: i have not at all verified if this RawEnd is correct yet.
//      extra_bytes: RawEnd(
//        vec![0, 0, 0, 0, 3, 165, 219, 245, 204, 2, 26, 33, 233, 112, 45, 138, 242, 145, 180, 98, 73, 145, 178, 65, 8, 137, 227, 69, 161, 156, 47, 249, 11, 96, 38, 201, 112, 104, 42, 188, 209, 3, 71, 45, 253, 238, 25, 216, 249, 72, 110, 191, 43, 253, 231, 12, 134, 215, 188, 0, 166, 33, 254, 38, 34, 137, 218, 11]
//      )
//    },
//    iter.next().unwrap()
//  )
//}
